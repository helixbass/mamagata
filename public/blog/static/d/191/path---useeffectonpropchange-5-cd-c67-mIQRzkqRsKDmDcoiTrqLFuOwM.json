{"data":{"site":{"siteMetadata":{"title":"Helixbassment","author":"Julian Rosse"}},"markdownRemark":{"id":"3f9f1a0b-ca51-5b0b-afba-0c618ad00d38","excerpt":"Handy React hooks helper: The old way: “prop-diffing” in In the days before React hooks, a typical pattern would be to compare the previous and new values of a…","html":"<h1>Handy React hooks helper: <code class=\"language-text\">useEffectOnPropChange()</code></h1>\n<h3>The old way: “prop-diffing” in <code class=\"language-text\">componentDidUpdate()</code></h3>\n<p>In the days before React hooks, a typical pattern would be to compare the previous and new values of a certain prop in a\nlifecycle method like <code class=\"language-text\">componentDidUpdate()</code> and conditionally “do something” if that prop had changed values in some\nparticular way</p>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Watcher extends React.Component {\n  ...\n  componentDidUpdate(prevProps) {\n    if (this.props.foo !== prevProps.foo &amp;&amp; this.props.foo === &#39;bar&#39;) {\n      console.log(&quot;foo just changed to &#39;bar&#39;&quot;)\n    }\n  }\n}</code></pre></div>\n<p>This type of “prop-diffing” always felt pretty boilerplate-y/hard to read - you’re sort of intermixing the mechanics of\ninspecting for a certain type of prop change having taken place with the action that should happen if that condition is met</p>\n<h3>The new standard: <code class=\"language-text\">useEffect()</code></h3>\n<p>These days, using class component lifecycle methods can typically be replaced by React hooks, in this case primarily\n<a href=\"https://reactjs.org/docs/hooks-effect.html\"><code class=\"language-text\">useEffect()</code></a></p>\n<p>The React hooks docs show us the <a href=\"https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state\">basic pattern for getting a reference to the previous props</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {useRef, useEffect} from &#39;React&#39;\n\nfunction usePrevious(value) {\n  const ref = useRef()\n  useEffect(() =&gt; {\n    ref.current = value\n  })\n  return ref.current\n}\n\nconst Compare = props =&gt; {\n  const prevProps = usePrevious(props) || {}\n  return &lt;h1&gt;Previous foo: {prevProps.foo}, current foo: {props.foo}&lt;/h1&gt;\n}</code></pre></div>\n<p>You can see that the <code class=\"language-text\">usePrevious()</code> helper is using the <code class=\"language-text\">useRef()</code> hook to track the previous value of something (in this case,\nthe props passed to the <code class=\"language-text\">&lt;Compare&gt;</code> component)</p>\n<p>So with <code class=\"language-text\">usePrevious()</code> as a building block, we can create an abstraction that allows us to say “when some particular prop\nchanges, do something”:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {find} from &#39;lodash&#39;\n\nconst useEffectOnPropChange = (changeProps, callback) =&gt; props =&gt; {\n  const prevProps = usePrevious(props) || {}\n  useEffect(() =&gt; {\n    const changed = find(\n      ensureArray(changeProps),\n      changeProp =&gt; prevProps[changeProp] !== props[changeProp]\n    )\n    if (!changed) return null\n    return callback(props, prevProps)\n  })\n}\n\nconst Watcher = props =&gt; {\n  useEffectOnPropChange(&#39;foo&#39;, ({foo}, prevProps) =&gt; {\n    if (foo === &#39;bar&#39; &amp;&amp; prevProps.foo === &#39;baz&#39;) {\n      console.log(&quot;foo just changed to &#39;bar&#39; from &#39;baz&#39;&quot;)\n    }\n  })(props)\n  ...\n}</code></pre></div>\n<p>Here <code class=\"language-text\">ensureArray()</code> is a helper that allows the first argument to <code class=\"language-text\">useEffectOnPropChange()</code> to either be an array of prop\nnames or a single prop name:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {isArray} from &#39;lodash&#39;\n\nconst ensureArray = maybeArray =&gt;\n  isArray(maybeArray) ? maybeArray : [maybeArray]\n\n...\n// both of these calling styles work:\nuseEffectOnPropChange(&#39;foo&#39;, ...)(props)\nuseEffectOnPropChange([&#39;foo&#39;, &#39;bar&#39;], ...)(props)</code></pre></div>\n<p>So with <code class=\"language-text\">useEffectOnPropChange()</code> we’ve given ourselves a more declarative way to indicate that something should happen\nwhenever a certain prop changes value</p>\n<p>This is a lot nicer than manually “prop-diffing” inside <code class=\"language-text\">componentDidUpdate()</code>, but I think there’s room to make it even more\ndeclarative. Basically now <code class=\"language-text\">useEffectOnPropChange()</code> is declarative with respect to <em>which prop we’re watching</em> but not with\nrespect to <em>under which conditions we care</em> - often times (like in the example above), our condition is actually more specific\nthan just “the <code class=\"language-text\">foo</code> prop changed”, it’s actually eg “the <code class=\"language-text\">foo</code> prop went from being null to non-null” or “the new value of the\n<code class=\"language-text\">foo</code> prop is <code class=\"language-text\">&#39;bar&#39;</code>”</p>\n<p>I can picture a couple different ways of making those cases more declarative:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Maybe these common cases deserve their own name:\nuseEffectOnPropBecomingTruthy(&#39;foo&#39;, ...)(props)\nuseEffectOnPropBecomingFalsy(&#39;foo&#39;, ...)(props)\n\n// Here&#39;s one calling interface for specifying the prop change condition separately from the action:\nuseEffectOnPropChange({foo: (currentFoo, prevFoo) =&gt; currentFoo === &#39;bar&#39; &amp;&amp; prevFoo === &#39;baz&#39;}, ...)(props)\n\n// Or similarly:\nuseEffectOnPropChangeWhen((props, prevProps) =&gt; props.foo === &#39;bar&#39; &amp;&amp; prevProps.foo === &#39;baz&#39;)(&#39;foo&#39;, ...)(props)</code></pre></div>\n<p>These might all be nice ways to express a condition in different situations - the goal is to feel empowered to create the\nnice abstractions that you (and others) can then reach for when you encounter a situation where they’d come in handy!</p>\n<p>For example, here’s how I might implement <code class=\"language-text\">useEffectOnPropBecomingTruthy()</code>:</p>\n<p>First, I think we’re going to need a general way to “inject the condition” into <code class=\"language-text\">useEffectOnPropChange()</code>. Looking at the\nideas for different calling interfaces above, I think it’ll make sense to make <code class=\"language-text\">useEffectOnPropChangeWhen()</code> our underlying\nabstraction that all the rest (including <code class=\"language-text\">useEffectOnPropChange()</code>) are built on top of</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useEffectOnPropChangeWhen = (condition = () =&gt; true) =&gt; (changeProps, callback) =&gt; props =&gt; {\n  const prevProps = usePrevious(props) || {}\n  useEffect(() =&gt; {\n    const changed = find(\n      ensureArray(changeProps),\n      changeProp =&gt; prevProps[changeProp] !== props[changeProp]\n    )\n    if (!changed) return null\n    if (!condition(props, prevProps)) return null\n    return callback(props, prevProps)\n  })\n}</code></pre></div>\n<p>We basically just added another “level of currying” to our previous <code class=\"language-text\">useEffectOnPropChange()</code> implementation in order to\naccept the additional <code class=\"language-text\">condition</code></p>\n<p>So now we can reimplement <code class=\"language-text\">useEffectOnPropChange()</code> in terms of <code class=\"language-text\">useEffectOnPropChangeWhen()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useEffectOnPropChange = (changeProps, callback) =&gt;\n  useEffectOnPropChangeWhen()(changeProps, callback)\n  \n// or just:\nconst useEffectOnPropChange = useEffectOnPropChangeWhen()</code></pre></div>\n<p>And now we can implement variations like <code class=\"language-text\">useEffectOnPropBecomingTruthy()</code> also using <code class=\"language-text\">useEffectOnPropChangeWhen()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const useEffectOnPropBecomingTruthy = (changeProps, callback) =&gt; {\n  const arrayOfChangeProps = ensureArray(changeProps)\n  const condition = (props, prevProps) =&gt;\n    find(arrayOfChangeProps, changeProp =&gt; props[changeProp] &amp;&amp; !prevProps[changeProp])\n  return useEffectOnPropChangeWhen(condition)(changeProps, callback)\n}</code></pre></div>\n<h3>Bonus: use <code class=\"language-text\">ad-hok</code></h3>\n<p>These are all nicely declarative <a href=\"https://reactjs.org/docs/hooks-custom.html\">“custom hooks”</a>. But I typically use\n<a href=\"https://github.com/helixbass/ad-hok\"><code class=\"language-text\">ad-hok</code></a> to allow composing hooks like this more fluidly</p>\n<p>It’s trivial to convert these custom hooks into <code class=\"language-text\">ad-hok</code>-style helpers:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addEffectOnPropChange = (changeProps, callback) =&gt; {\n  const curriedUseEffectOnPropChange = useEffectOnPropChange(changeProps, callback)\n  return props =&gt; {\n    curriedUseEffectOnPropChange(props)\n    return props\n  }\n}</code></pre></div>\n<p>or written in a more functional style:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {flow} from &#39;lodash/fp&#39;\n\nconst addEffectOnPropChange = flow(\n  useEffectOnPropChange,\n  tap\n)</code></pre></div>\n<p>where <code class=\"language-text\">tap()</code> is a <a href=\"https://ramdajs.com/0.21.0/docs/#tap\">standard</a> <a href=\"https://apidock.com/ruby/Object/tap\">functional</a> <a href=\"http://raganwald.com/JQuery-Combinators/\">helper</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const tap = callback =&gt; val =&gt; {\n  callback(val)\n  return val\n}</code></pre></div>\n<p>The above is elegantly simple but might be hard to visualize, so here’s a version where the flow of arguments is more explicit:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addEffectOnPropChange = flow(\n  (changeProps, callback) =&gt; useEffectOnPropChange(changeProps, callback),\n  curriedUseEffectOnPropChange =&gt; {\n    return props =&gt; {\n      curriedUseEffectOnPropChange(props)\n      return props\n    }\n  }\n)</code></pre></div>\n<p>Then we can use <code class=\"language-text\">addEffectOnPropChange()</code> in an <code class=\"language-text\">ad-hok</code>-style component:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Watcher = flow(\n  addEffectOnPropChange(&#39;foo&#39;, ({foo}, prevProps) =&gt; {\n    if (foo === &#39;bar&#39; &amp;&amp; prevProps.foo === &#39;baz&#39;) {\n      console.log(&quot;foo just changed to &#39;bar&#39; from &#39;baz&#39;&quot;)\n    }\n  }),\n  ...\n)</code></pre></div>\n<h3>Practical use case: tracking current language</h3>\n<p>In the current project I’m working on, we’re using <a href=\"https://www.i18next.com/\"><code class=\"language-text\">i18next</code></a>/<a href=\"https://react.i18next.com/\"><code class=\"language-text\">react-i18next</code></a>\nfor internationalization support (translations)</p>\n<p>It seems as though <code class=\"language-text\">i18next</code> expects to be the “source of truth” for what the currently selected language is. But that felt\nsomewhat at odds with our Redux store being the source of truth for most similar state. And at some point I felt like I was\nseeing wonky/flaky updating of <code class=\"language-text\">i18next</code>’s version of what the currently selected language is</p>\n<p>So at that point I decided to move the current language “source of truth” into our Redux store and have <code class=\"language-text\">i18next</code>’s idea of\nthe current language be informed by our Redux store</p>\n<p>There may be a more idiomatic way of “broadcasting” a value from your Redux store, but the way I achieved this was to create\na component (that gets mounted at the root level of our application) whose sole purpose is to listen to the Redux store for\nchanges to the current language and inform <code class=\"language-text\">i18next</code> of that change:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {connect} from &#39;react-redux&#39;\nimport {flowMax, renderNothing} from &#39;ad-hok&#39;\nimport i18n from &#39;i18next&#39;\nimport PropTypes from &#39;prop-types&#39;\n\nimport {languageSelector} from &#39;redux-local/selectors&#39;\nimport addEffectOnPropChange from &#39;util/addEffectOnPropChange&#39;\n\nconst enhance = connect(languageSelector)\n\nconst WatchLanguage = flowMax(\n  ...\n  addEffectOnPropChange(&#39;currentLanguage&#39;, ({currentLanguage}) =&gt; {\n    i18n.changeLanguage(currentLanguage)\n  }),\n  renderNothing()\n)\n\nWatchLanguage.propTypes = {\n  currentLanguage: PropTypes.string.isRequired,\n}\n\nexport default enhance(WatchLanguage)</code></pre></div>\n<p><code class=\"language-text\">addEffectOnPropChange()</code> makes it super easy to fire off the call to <code class=\"language-text\">i18n.changeLanguage()</code> whenever our Redux store’s\n<code class=\"language-text\">currentLanguage</code> changes</p>","frontmatter":{"title":"","date":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/useeffectonpropchange/","previous":{"fields":{"slug":"/slack-personal-activity-channel/"},"frontmatter":{"title":"Slack tip: personal activity channel"}},"next":null}}