{"data":{"site":{"siteMetadata":{"title":"Helixbassment","author":"Julian Rosse"}},"markdownRemark":{"id":"fdbe66f3-f9a6-5159-98f9-9b4459dac272","excerpt":"The problemOn the current project, we have a video inside a “lightbox”-style modal. We got design feedback that it would be nice\nfor the video to autoplay when…","html":"<h3>The problem</h3>\n<p>On the current project, we have a video inside a “lightbox”-style modal. We got design feedback that it would be nice\nfor the video to autoplay when the modal is opened</p>\n<p>However, by default when setting the video to autoplay, it was playing muted in Safari/iOS Safari (requiring an additional\ntap to unmute). Since iPad is the primary deployment target for this project and the design feedback was that it should only\nautoplay if it can play unmuted, we decided to try and figure out a way to achieve that</p>\n<p>We felt like in theory it should be doable since even though browsers have been tightening up their autoplay policies, there\nhas to be a way to play a video unmuted based on explicit user action, and here there was an explicit user action taking place\nbefore playing the video (clicking to open the modal)</p>\n<p>So <a href=\"https://github.com/amay\">Alex</a> figured that (from a React perspective) effectively if the video were already mounted\nbefore the modal was opened and then we did something more like an imperative <code class=\"language-text\">.play()</code> command when the modal was opened,\nit was likely that the video would play unmuted</p>\n<h3>The obstacle</h3>\n<p>If the modal itself could be mounted “up front” and simply kept visually hidden (via CSS) until it was toggled open, that\nwould be straightforward, as the video component inside the modal would also be pre-mounted along with the modal itself</p>\n<p>However, on this project we’re using <a href=\"https://react-bootstrap.github.io/\"><code class=\"language-text\">react-bootstrap</code></a>, which states in its <a href=\"https://react-bootstrap.github.io/components/modal/\"><code class=\"language-text\">Modal</code>\ndocs</a> that “Modals are <em>unmounted</em> when closed”</p>\n<p>And it didn’t seem viable to try and use a different type of modal just for this particular instance</p>\n<p>So the only option for having the video pre-mounted before the modal opened seemed to be to somehow mount it somewhere and\nthen “move” it to inside the modal once the modal had mounted</p>\n<h3>Portals to the rescue?</h3>\n<p>The React-y way to achieve that would be with a <a href=\"https://reactjs.org/docs/portals.html\">portal</a>. If you haven’t seen React\nportals before, basically they allow you to render something inside any arbitrary DOM node (rather than inside its React\nparent)</p>\n<p>I had never seen a “dynamic portal” that changed its target parent DOM node “mid-flight”, but that seemed like\nthe most obvious way to structure it - mount the video inside some visually hidden parent container initially (via a portal)\nand then when the modal opened, <em>\\</em>poof** change the portal destination to the modal!</p>\n<h3>tl;dr it worked</h3>\n<p>Using this dynamic portal to premount the video, it did in fact play unmuted in Safari!</p>\n<h3>The code</h3>\n<p>So let’s look at the specific code patterns used to create this “dynamic portal”</p>\n<p>Portals expect to be given an actual DOM node (for the destination). So in React, when you hear “actual DOM node” you should\nbe thinking “ref”</p>\n<p>Here, we need two refs since we need two DOM nodes for the portal destination - a visually hidden container and then the modal</p>\n<p>Initially I tried using <a href=\"https://reactjs.org/docs/refs-and-the-dom.html#creating-refs\">“new-style refs”</a>, since these days I’d\ndefault to using that style of ref. But I wasn’t seeing the portal rerendering reliably once the refs were populated</p>\n<p>This was new to me, but apparently that’s known/expected behavior when using new-style refs via the <a href=\"https://reactjs.org/docs/hooks-reference.html#useref\"><code class=\"language-text\">useRef</code> hook</a>\nand if you need to trigger rerendering based on a ref changing, you need to use <a href=\"https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node\">callback-style refs</a>\ninstead</p>\n<p>So here’s how I wired up the two callback-style refs:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {flow} from &#39;lodash/fp&#39;\n\nconst VideoAnswer = flow(\n  ...\n  addCallbackRefAndNode(\n    &#39;lightboxPortalTargetCallbackRef&#39;,\n    &#39;lightboxPortalTargetNode&#39;\n  ),\n  addCallbackRefAndNode(\n    &#39;visuallyHiddenVideoContainerCallbackRef&#39;,\n    &#39;visuallyHiddenVideoContainerNode&#39;\n  ),\n  ...\n  ({\n    ...\n    lightboxPortalTargetCallbackRef,\n    visuallyHiddenVideoContainerCallbackRef,\n    ...\n  }) =&gt;\n    ...\n      &lt;div\n        css={a11yStyles.visuallyHidden}\n        aria-hidden=&quot;true&quot;\n        ref={visuallyHiddenVideoContainerCallbackRef}\n      /&gt;\n      &lt;Lightbox\n        ...\n        childPortalTargetRef={lightboxPortalTargetCallbackRef}\n      /&gt;\n    ...\n)</code></pre></div>\n<p>First of all, this is an <a href=\"https://github.com/helixbass/ad-hok\"><code class=\"language-text\">ad-hok</code></a>-style component using <a href=\"https://simonsmith.io/dipping-a-toe-into-functional-js-with-lodash-fp#compose-yourself\"><code class=\"language-text\">flow()</code></a>.\n<code class=\"language-text\">ad-hok</code> is allowing us to build up component functionality in a highly composable way similar to <a href=\"https://github.com/acdlite/recompose\">Recompose</a>,\nbut where you’re using React hooks instead of higher-order components as your building blocks</p>\n<p><code class=\"language-text\">addCallbackRefAndNode()</code> is a helper for exposing a callback-style ref and the node it references:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {flow} from &#39;lodash/fp&#39;\nimport {upperFirst} from &#39;lodash&#39;\nimport {addState, addCallback} from &#39;ad-hok&#39;\n\nconst addCallbackRefAndNode = flow(\n  (refPropName, nodePropName) =&gt; ({\n    refPropName,\n    nodePropName,\n    setNodePropName: `set${upperFirst(nodePropName)}`,\n  }),\n  ({refPropName, nodePropName, setNodePropName}) =&gt;\n    flow(\n      addState(nodePropName, setNodePropName),\n      addCallback(\n        refPropName,\n        ({[setNodePropName]: setNode}) =&gt; node =&gt; {\n          setNode(node)\n        },\n        []\n      )\n    )\n)</code></pre></div>\n<p>Here, <code class=\"language-text\">addState()</code> and <code class=\"language-text\">addCallback()</code> are <code class=\"language-text\">ad-hok</code> helpers that wrap the <code class=\"language-text\">useState()</code> and <code class=\"language-text\">useCallback()</code> hooks, respectively.\nSo <code class=\"language-text\">addCallbackRefAndNode()</code> is encapsulating a state variable for the callback ref to assign the DOM node reference to</p>\n<p>And the <code class=\"language-text\">childPortalTargetRef</code> is a new prop I added to our <code class=\"language-text\">&lt;Lightbox&gt;</code> component to allow wiring up the ref to the modal body:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Lightbox = ({\n  ...\n  childPortalTargetRef,\n}) =&gt; (\n  &lt;Modal\n    ...\n  &gt;\n    &lt;Modal.Body\n      ...\n      ref={childPortalTargetRef}\n    &gt;\n      ...\n    &lt;/Modal.Body&gt;\n  &lt;/Modal&gt;\n)</code></pre></div>\n<p>So that takes care of getting references to the two DOM nodes we need</p>\n<p>Then we want to dynamically change which one the portal uses as its destination based on whether the modal is open:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">      &lt;Portal\n        to={showingModal ? lightboxPortalTargetNode : visuallyHiddenVideoContainerNode}\n      &gt;\n        &lt;Video\n          ...\n          playing={showingModal}\n        /&gt;\n      &lt;/Portal&gt;</code></pre></div>\n<p>where <code class=\"language-text\">&lt;Portal&gt;</code> is just a simple wrapper around <code class=\"language-text\">React.createPortal()</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {createPortal} from &#39;react-dom&#39;\nimport {flowMax, branch, renderNothing} from &#39;ad-hok&#39;\n\nimport {childrenPropType, domNodePropType} from &#39;util/propTypes&#39;\n\nconst Portal = flowMax(\n  branch(({to}) =&gt; !to, renderNothing()),\n  ({to, children}) =&gt; createPortal(children, to)\n)\n\nPortal.propTypes = {\n  to: domNodePropType,\n  children: childrenPropType.isRequired,\n}</code></pre></div>\n<p>That’s the gist of the dynamic portal implementation</p>\n<p>For completeness’ sake, I also ran into a little weird behavior in Chrome: for some reason when the modal was closed, the\nvideo’s audio was restarting and continuing to play (rather than the video stopping when the modal closed). We’re using\n<a href=\"https://www.npmjs.com/package/react-player\"><code class=\"language-text\">react-player</code></a> as an abstraction around the actual HTML5 <code class=\"language-text\">&lt;video&gt;</code> inside our\n<code class=\"language-text\">&lt;Video&gt;</code> component, so it’s possible its internal state got wonky. But regardless, we can seize control of the situation by\nmaking sure the video is fully unmounted after the modal has been closed</p>\n<p>First, set up a <code class=\"language-text\">hasModalBeenClosed</code> state variable:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import {..., addStateHandlers} from &#39;ad-hok&#39;\n\nconst addVideoUnmountingOnModalClose = flow(\n  addStateHandlers(\n    {hasModalBeenClosed: false},\n    {\n      onModalClose: () =&gt; () =&gt; ({\n        hasModalBeenClosed: true,\n      }),\n    }\n  ),\n  addEffectOnPropChange(\n    [&#39;showingModal&#39;],\n    ({showingModal, onModalClose}, prevProps) =&gt; {\n      if (!showingModal &amp;&amp; prevProps.showingModal) {\n        onModalClose()\n      }\n    }\n  )\n)</code></pre></div>\n<p>This uses the handy <a href=\"./addEffectOnPropChange\"><code class=\"language-text\">addEffectOnPropChange()</code> helper</a></p>\n<p>And then we’ll consider the value of <code class=\"language-text\">hasModalBeenClosed</code> when deciding what the portal destination should be</p>\n<p>Putting it all together:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const addVideoUnmountingOnModalClose = flow(\n  addStateHandlers(\n    {hasModalBeenClosed: false},\n    {\n      onModalClose: () =&gt; () =&gt; ({\n        hasModalBeenClosed: true,\n      }),\n    }\n  ),\n  addEffectOnPropChange(\n    [&#39;showingModal&#39;],\n    ({showingModal, onModalClose}, prevProps) =&gt; {\n      if (!showingModal &amp;&amp; prevProps.showingModal) {\n        onModalClose()\n      }\n    }\n  )\n)\n\nconst getVideoPortalTarget = ({\n  showingModal,\n  lightboxPortalTargetNode,\n  hasModalBeenClosed,\n  visuallyHiddenVideoContainerNode,\n}) =&gt; {\n  if (showingModal) return lightboxPortalTargetNode\n  if (hasModalBeenClosed) return null\n  return visuallyHiddenVideoContainerNode\n}\n\nconst VideoAnswer = flow(\n  ...\n  addState(&#39;showingModal&#39;, &#39;setShowingModal&#39;, false),\n  addCallbackRefAndNode(\n    &#39;lightboxPortalTargetCallbackRef&#39;,\n    &#39;lightboxPortalTargetNode&#39;\n  ),\n  addCallbackRefAndNode(\n    &#39;visuallyHiddenVideoContainerCallbackRef&#39;,\n    &#39;visuallyHiddenVideoContainerNode&#39;\n  ),\n  addVideoUnmountingOnModalClose,\n  ({\n    ...\n    showingModal,\n    lightboxPortalTargetCallbackRef,\n    lightboxPortalTargetNode,\n    visuallyHiddenVideoContainerCallbackRef,\n    visuallyHiddenVideoContainerNode,\n    hasModalBeenClosed,\n  }) =&gt; (\n    &lt;&gt;\n      ...\n      &lt;div\n        css={a11yStyles.visuallyHidden}\n        aria-hidden=&quot;true&quot;\n        ref={visuallyHiddenVideoContainerCallbackRef}\n      /&gt;\n      &lt;Portal\n        to={getVideoPortalTarget({\n          showingModal,\n          lightboxPortalTargetNode,\n          hasModalBeenClosed,\n          visuallyHiddenVideoContainerNode,\n        })}\n      &gt;\n        &lt;Video\n          ...\n          playing={showingModal}\n        /&gt;\n        ...\n      &lt;/Portal&gt;\n      &lt;Lightbox\n        show={showingModal}\n        ...\n        childPortalTargetRef={lightboxPortalTargetCallbackRef}\n      /&gt;\n    &lt;/&gt;\n  )\n)</code></pre></div>\n<h4>Unresolved: a11y</h4>\n<p>This pattern seems to have achieved the desired behavior of getting unmuted autoplay to work cross-browser. But there’s an\noutstanding accessibility issue with it that I’m not sure if there’s a great solution to:</p>\n<p>When the video is initially mounted inside the visually-hidden container, it’s hidden from screen readers using\n<code class=\"language-text\">aria-hidden=&quot;true&quot;</code>. But it’s still keyboard-navigable (ie you can hit Tab and it will focus on the interactive elements of\nthe video component while it’s offscreen)</p>\n<p>I tried using the HTML5 <code class=\"language-text\">hidden</code> attribute instead of <code class=\"language-text\">aria-hidden=&quot;true&quot;</code>, but that reverted the autoplay muted behavior</p>\n<p>So I’m not sure if there’s a general a11y technique for making all interactive elements under a given parent container element\nnon-keyboard-navigable?</p>\n<p>Regardless, I think in this case achieving the desired autoplay behavior on the target iPad platform outweighs the potentially\nconfusing keyboard navigation. But it would be nice to cover our bases a11y-wise especially when thinking about reusing this\ntechnique in the future</p>","frontmatter":{"title":"Using dynamic portals in React to “play nice with” autoplay policy","date":"May 12, 2019"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/dynamic-portal/","previous":{"fields":{"slug":"/useeffectonpropchange/"},"frontmatter":{"title":"Handy React hooks helper: useEffectOnPropChange()"}},"next":null}}